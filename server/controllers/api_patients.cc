/**
 *
 *  api_patients.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "api_patients.h"
#include <string>
#include <sqlite3.h>
#include <cassert>
#include <drogon/orm/DbClient.h>

namespace api
{
  using std::cerr;

  void
  patients::getOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   std::string &&id)
  {
    LOG_DEBUG << "User " << id << " get his information";

    // Verify the validity of the token, etc.
    // Read the database or cache to get user information
    auto ret = Json::Value();
    ret["result"] = "ok";
    ret["user_name"] = "Jack";
    ret["user_id"] = id;
    ret["gender"] = 1;
    auto resp = HttpResponse::newHttpJsonResponse(ret);
    callback(resp);
  }

  void
  patients::get(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback)
  {
  }
  void
  patients::create(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback)
  {
  }
  void
  patients::updateOne(const HttpRequestPtr &req,
                      std::function<void(const HttpResponsePtr &)> &&callback,
                      std::string &&id)
  {
  }

  /*
  void patients::update(const HttpRequestPtr &req,
                        std::function<void(const HttpResponsePtr &)>
  &&callback)
  {

  }*/

  void
  patients::deleteOne(const HttpRequestPtr &req,
                      std::function<void(const HttpResponsePtr &)> &&callback,
                      std::string &&id)
  {
  }

  enum parser
  {
    noParserError = 0
  };

  enum db
  {

    userNotInDb = 0,
    userInsted = 1,
  };

  auto
  patients::login(
      HttpRequestPtr const &req,
      std::function<auto(HttpResponsePtr const &)->void> &&callback) -> void
  {
    // Authentication algorithm, read database, verify identity, etc...
    auto parser = MultiPartParser();
    if (parser.parse(req) == 0)
      {
        auto const &params = parser.getParameters();
        auto const email = params.at("email");
        auto const password = params.at("password");
        auto clientPtr = drogon::app().getDbClient();
        if (clientPtr)
          {
            clientPtr->execSqlAsync(
                "SELECT * from Patients WHERE Email = :email AND Password = "
                ":password",
                [callback](const drogon::orm::Result &result) {
                  auto ret = Json::Value();
                  if (result.size() == db::userNotInDb)
                    {
                      ret["status_code"] = HttpStatusCode::k401Unauthorized;
                      ret["message"] = "you are unauthorized";
                      auto resp = HttpResponse::newHttpJsonResponse(ret);
                      resp->setStatusCode(HttpStatusCode::k401Unauthorized);
                      callback(resp);
                    }
                  else
                    {
                      ret["message"] = "ok";
                      ret["status_code"] = HttpStatusCode::k200OK;
                      ret["token"] = drogon::utils::getUuid();
                      auto resp = HttpResponse::newHttpJsonResponse(ret);
                      resp->setStatusCode(HttpStatusCode::k200OK);
                      callback(resp);
                    }
                },
                [callback](const drogon::orm::DrogonDbException &e) {
                  auto ret = Json::Value();
                  cerr << "error:" << e.base().what() << '\n';
                  ret["status_code"] = HttpStatusCode::k500InternalServerError;
                  ret["message"] = "An error occured on the server side\n"
                                   "Contact the administrator to get it fixed";
                  auto resp = HttpResponse::newHttpJsonResponse(ret);
                  resp->setStatusCode(HttpStatusCode::k500InternalServerError);
                  callback(resp);
                },
                email, password);
          }
        else
          {

            LOG_DEBUG << "There is an issue with the db connetion\n";
          }
      }
  }

  auto
  patients::signup(
      HttpRequestPtr const &req,
      std::function<auto(HttpResponsePtr const &)->void> &&callback) -> void
  {
    // Authentication algorithm, read database, verify identity, etc...
    auto parser = MultiPartParser();
    if (parser.parse(req) == parser::noParserError)
      {
        auto const &params = parser.getParameters();
        auto const email = params.at("email");
        auto clientPtr = drogon::app().getDbClient();
        if (clientPtr)
          {
            *clientPtr << "SELECT * from Patients WHERE Email = :email"
                       << email
                >>
                [clientPtr, callback,
                 parser](bool emailNotInDb, std::string const & /*UserName*/,
                         std::string const & /*Email*/,
                         std::string const & /*Password*/) {
                  if (emailNotInDb)
                    {
                      auto const &params = parser.getParameters();
                      auto const &email = params.at("email");
                      auto const &username = params.at("username");
                      auto const &password = params.at("password");
                      LOG_DEBUG << "Form data's email has value " << email
                                << " username " << username << " password "
                                << password;
                      clientPtr->execSqlAsync(
                          "INSERT INTO Patients VALUES "
                          "($username,$email,$password)",
                          [callback](const drogon::orm::Result &result) {
                            auto ret = Json::Value();
                            if (result.affectedRows() == db::userInsted)
                              {
                                ret["message"] = "Registed Successfully";
                                ret["status_code"] = HttpStatusCode::k200OK;
                                ret["token"] = drogon::utils::getUuid();
                                auto resp
                                    = HttpResponse::newHttpJsonResponse(ret);
                                resp->setStatusCode(HttpStatusCode::k200OK);
                                callback(resp);
                              }
                          },
                          [callback](const drogon::orm::DrogonDbException &e) {
                            auto ret = Json::Value();
                            cerr << "error:" << e.base().what() << '\n';
                            ret["status_code"]
                                = HttpStatusCode::k500InternalServerError;
                            ret["message"]
                                = "An error occured on the server side"
                                  "Contact the administrator to get it fixed";
                            auto resp = HttpResponse::newHttpJsonResponse(ret);
                            resp->setStatusCode(
                                HttpStatusCode::k500InternalServerError);
                            callback(resp);
                          },
                          username, email, password);
                    }
                  else
                    {
                      auto ret = Json::Value();
                      ret["status_code"] = HttpStatusCode::k401Unauthorized;
                      ret["message"] = "User Account already exist";
                      auto resp = HttpResponse::newHttpJsonResponse(ret);
                      resp->setStatusCode(HttpStatusCode::k401Unauthorized);
                      callback(resp);
                    }
                }
                >>
                [](const drogon::orm::DrogonDbException &e) {
                  cerr << "Sql error:" << e.base().what() << std::endl;
                  auto const *sql
                      = dynamic_cast<const drogon::orm::SqlError *>(&e.base());
                  if (sql != nullptr)
                    {
                      cerr << "Query was: " << sql->query() << '\n';
                      cerr << "Sql state was: " << sql->sqlState() << '\n';
                      cerr << "Sql error: " << sql->what() << '\n';
                    }
                };
          }
      }
  }
} // namespace api
